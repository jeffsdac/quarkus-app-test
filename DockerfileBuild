# ----------------------------------------------------
# STAGE 1: BUILD (Compilação e preparação do JAR)
# ----------------------------------------------------
FROM registry.access.redhat.com/ubi8/openjdk-17 AS build

# Define o diretório de trabalho
WORKDIR /project

# Copia os arquivos necessários para o Maven Wrapper
COPY mvnw .
COPY .mvn .mvn

# Copia o pom.xml (para cache de dependências)
COPY pom.xml .

# Baixa dependências (cache eficiente)
RUN chmod +x mvnw && ./mvnw dependency:go-offline

# Copia o código-fonte do projeto
COPY src src

# Faz o build do JAR final
# O '-DskipTests' é opcional, mas comum para builds rápidos no Docker
RUN ./mvnw package -DskipTests

# ----------------------------------------------------
# STAGE 2: RUNTIME (Imagem final, leve, para executar a JVM)
# ----------------------------------------------------
# Usamos o OpenJDK UBI para runtime, que é otimizado para containers
FROM registry.access.redhat.com/ubi8/openjdk-17-runtime

# Define o diretório de trabalho
WORKDIR /app

# Copia os arquivos de Libs (dependências) e o JAR principal
# O Quarkus gera o JAR principal (runner.jar) e a pasta de libs
COPY --from=build /project/target/quarkus-app/lib /app/lib
COPY --from=build /project/target/quarkus-app/*.jar /app
COPY --from=build /project/target/quarkus-app/app /app/app
COPY --from=build /project/target/quarkus-app/quarkus /app/quarkus

# Expõe a porta
EXPOSE 8080

# Define o usuário não-root (geralmente 1001 na UBI)
USER 1001

# Comando de entrada: Executa a aplicação Quarkus em modo JVM
ENTRYPOINT ["java", "-jar", "quarkus-run.jar"]